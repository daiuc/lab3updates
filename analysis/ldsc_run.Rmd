---
title: "ldsc_run"
author: "daiuc"
date: "2021-08-17"
output: workflowr::wflow_html
editor_options: 
  chunk_output_type: inline
---


```{r message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(echo = T, warning = F, message = F, echo = FALSE)
```


## Objective 1: estimate each gene's total cis heritability

A given gene's total heritability can be estimated by first estimate average per SNP heritability for each annotation category $\bar{\tau_c}$. Then A given gene's total heritability can be computed by multiplying number of all qualifying SNPs in cis
Modified `ldsc` codes to output $\tau_c$ of each category as well as overlapping SNPs. 



$$h^2_g(total) = \sum_C{M_c \bar{\tau_c}}$$

To compute $M_c$ and $\bar{\tau_c}$, I made these modifications in the original scripts of [LD SCore v1.0.1](https://github.com/bulik/ldsc):

- Output number of SNPs for each category, essentially an inner join between cis-eQTL summary stats SNPs and LD score SNPs from each of the 53 category (including base, ie. just SNPs). 
- This involves modifying the functions of:
    - `annot_parser`, `annot` functions in the `parse.py` script
    - `_read_annot` function in the `sumstats.py` script
    - `_overlap_output` method in the `regression.py` script
- With the modification, `ldsc` will now output correct intersected `M_annot` or number of cis-eQTL SNPs for each category
- Code for computing coefficient is not modified, since it already only take in intersection between ld score SNPs and cis-eQTL SNPs

Result:
- $h^2$ for 18373 genes are estimated


[Modified code](modified_code.html)


---


## Objective 2: estimate impact of functional and regulatory traits on cis heritability

Effectively, we now compare cis gene heritability estimated from above with other metrics that measure regulatory or functional characteristics of genomic regions / genes.

The following dataset from Wang et al. AJHG 2020 ([link](https://doi.org/10.1016/j.ajhg.2020.01.012)) are used. `15,913` genes are incorporated from this dataset (after removing NA values). The `h^2` dataset and teh `EDS` dataset are joined together on gene IDs. After having removed negative `h^2` genes, `8,936` genes remain. Zscores are computed for each gene. 




<br> 


```{r include=FALSE, warning=FALSE, message=FALSE}
library(tidyverse)
library(data.table)

library(cowplot)
theme_set(theme_cowplot())
library(parallel)
detectCores()
```


```{r include=FALSE, warning=FALSE, message=FALSE}
# read in data
gene.lookup = fread("../eQTLs/data/geneID_geneSymbol_lookup.txt", sep = "\t", col.names = c("id","gene"))
eds = readxl::read_xlsx("../eQTLs/data/wang_et_al_2020_AJHG_eds_pLI_RVIS.xlsx")
gene.lengths = fread("../eQTLs/output/gencode.v31.primary.annotation.Protein_coding_gene_length.txt")
gtex = fread("../eQTLs/output/GTEx_v8_sigif_eQTL_summ.txt")
hsq = fread("../eQTLs/output/hsq.txt", sep="\t")
```


```{r include=FALSE}
# massaging data, bringing all data into 1 dataframe
hsq = inner_join(hsq, gene.lookup, by = "gene")
remove_gene = group_by(hsq, gene) %>% summarise(n=n()) %>% filter( n > 2) %>% pull(gene)
hsq = filter(hsq, ! gene %in% remove_gene) %>% 
        group_by(gene) %>% 
        summarise(h2 = mean(h2), m_tot = sum(m_tot)) %>%
        inner_join(gene.lookup, by = "gene")
hsq = inner_join(hsq[,c("id","gene","h2", "m_tot")], eds[, c("GeneSymbol", "EDS","pLI","RVIS")], by = c("id" = "GeneSymbol"))
hsq = mutate_at(hsq, .vars = c("pLI", "RVIS"), .funs = "as.numeric")
hsq = filter(hsq, h2 > 0)
hsq = inner_join(hsq, gtex, by = c("id" = "gene_id"))
hsq = inner_join(hsq, gene.lengths, by = c("id" = "gene_id"))
```

```{r}
hsq = mutate(hsq, h2.z = scale(h2)[,1], EDS.z = scale(EDS)[,1], pLI.z = scale(pLI)[,1], RVIS.z = scale(RVIS)[,1])
```


### Example of combined dataset

```{r echo=FALSE}
head(hsq) %>% select(-h2.z, -EDS.z, -pLI.z, -RVIS.z) %>% knitr::kable() %>% kableExtra::kable_styling()
```

<br>


### QC plots

After rounds of filtering about 9000 protein coding genes are left for downstream analysis



<br>

#### Summary stats of qualifying SNPs per gene

```{r echo=FALSE}
summary(hsq$m_tot)
```

<br>

#### Distribution of qualifying SNPs for $h^2$ estimate

```{r}
ggplot(hsq) + geom_density(aes(m_tot, ..density..), fill="royalblue", alpha=.5)
```


#### $h^2$ distribution

```{r, warning=FALSE, message=FALSE, }
ggplot(hsq) + geom_density(aes(x = h2, y = ..density..), fill = "coral", alpha = .5)
```

<br>

### Is cis genetic heritability related to regulatory landscape, functional intolerance and constraints, or gene length?


To answer this question, I investigated the following metrics:

**EDS**

EDS, or enhancer-domain score, reflects the total size and redundancy of a gene's non-coding regulatory architecture. *A higher EDS suggests a gene has higher non-coding regulatory interactions*. It was noted to be negatively correlated with cis eQTL ([Wang et al. 2020](https://doi.org/10.1016/j.ajhg.2020.01.012)). EDS is computed by first constructing enhancer domains for each gene from enhancer predictions from various data sources. For each enhancer domain per gene, domain size and redundancy of TF motifs are the main determinants of the final EDS value.

In my analysis, EDS data is downloaded from Wang et al. 2020 paper.


<br>

**RVIS**

RVIS (Residual Variation Intolerance Score) is designed to rank genes in terms of whether they have more or less common functional genetic variation *relative to the genome wide expectation* given the amount of apparently neutral variation the gene has. A gene with a positive score has more common functional variation, and a gene with a negative score has less and is referred to as "intolerant". By convention we rank all genes in order from most intolerant to least. As an example, a gene such as ATP1A3 has a RVIS score of -1.53 and a percentile of 3.37%, meaning it is amongst the 3.37% most intolerant of human genes. *A negative score indicates a gene has less than expected amount of functional variants, thus may be under purifying selection, while a positive score indicates higher than expected amount of functional variants, thus may be under balanced or positive selection.*

RVIS score in this analysis is downloaded from the Wang et al. 2020 paper.

**pLI**

pLI (probability of being loss-of-function intolerant) reflects the tolerance of a gene to the loss of function mutations. *A higher value of pLI indicates a gene's function is more likely to be abrogated under a loss-of-function mutation*. It is frequently used to prioritize candidate genes when analyzing whole exome or whole genome data. We list here the main pitfalls to consider before using this score.


#### Distributions of other gene metrics
```{r}
metrics = c("EDS", "pLI", "RVIS", "length", "max.abs.slope", "N_QTLs") %>% set_names
corrs = models = map(metrics, ~ cor.test(as.formula(paste("~", .x, "+", "h2")), data = hsq), method = "spearman")
corr.p = map(corrs, ~ .x$p.value)
corr.cor = map(corrs, ~ .x$estimate)
```

```{r}
gg = map2(metrics, 1:6, function(v,i) {ggplot(hsq) + geom_density(aes_string(v, "..density.."), fill = i, alpha = .5)})
```

```{r, warning=FALSE, message=FALSE, fig.height=8, fig.width=10}
gridExtra::grid.arrange(grobs = gg, nrow=3)
```


<br>

#### Demonstrating correlation between $h^2$ and other metrics

```{r include=FALSE}
gg.sc1 = ggplot(hsq, aes(h2, EDS)) +
    geom_point( alpha = .3) + 
    geom_smooth(method = "lm")
gg.sc2 = ggplot(hsq, aes(h2, pLI)) +
    geom_point( alpha = .3) + 
    geom_smooth(method = "lm")
gg.sc3 = ggplot(hsq, aes(h2, RVIS)) +
    geom_point( alpha = .3) + 
    geom_smooth(method = "lm")
gg.sc4 = ggplot(hsq, aes(h2, log10(length))) +
    geom_point( alpha = .3) + 
    geom_smooth(method = "lm")
gg.sc5 = ggplot(hsq, aes(h2, max.abs.slope)) +
    geom_point( alpha = .3) + 
    geom_smooth(method = "lm")
gg.sc6 = ggplot(hsq, aes(h2, N_QTLs)) +
    geom_point( alpha = .3) + 
    geom_smooth(method = "lm")
```



<br>

```{r, warning=FALSE, message=FALSE, fig.height=8, fig.width=10}
gridExtra::grid.arrange(gg.sc1, gg.sc2, gg.sc3, gg.sc4, gg.sc5, gg.sc6, nrow=3)
```

<br>


#### Demonstrating correlation between $h^2$ and other metrics

```{r, warning=FALSE, message=FALSE}

gg.bx1 = ggplot(hsq, aes(h2, EDS)) +
  geom_boxplot(aes(group = cut_width(h2, .01))) +
  geom_text(aes(x=.02, y= .9, label=paste("cor:", scales::comma(corr.cor$EDS, accuracy = .01), 
                            "p:", scales::scientific(corr.p$EDS))),color = 'blue')
gg.bx2 = ggplot(hsq, aes(h2, pLI)) +
  geom_boxplot(aes(group = cut_width(h2, .01))) +
  geom_text(aes(x=.02, y= .95, label=paste("cor:", scales::comma(corr.cor$pLI, accuracy = .01), 
                            "p:", scales::scientific(corr.p$pLI))),color = 'blue')
gg.bx3 = ggplot(hsq, aes(h2, RVIS)) +
  geom_boxplot(aes(group = cut_width(h2, .01))) +
  geom_text(aes(x=.02, y= 95, label=paste("cor:", scales::comma(corr.cor$RVIS, accuracy = .01), 
                            "p:", scales::scientific(corr.p$RVIS))),color = 'blue')
gg.bx4 = ggplot(hsq, aes(h2, length)) +
  geom_boxplot(aes(group = cut_width(h2, .01))) +
  scale_y_log10() +
  geom_text(aes(x=.02, y= quantile(length, .95), label=paste("cor:", scales::comma(corr.cor$length, accuracy = .01), 
                            "p:", scales::scientific(corr.p$length))),color = 'blue')
gg.bx5 = ggplot(hsq, aes(h2, max.abs.slope)) +
  geom_boxplot(aes(group = cut_width(h2, .01))) +
  geom_text(aes(x=.02, y= max(max.abs.slope), label=paste("cor:", scales::comma(corr.cor$max.abs.slope, accuracy = .01), 
                            "p:", scales::scientific(corr.p$max.abs.slope))),color = 'blue')
gg.bx6 = ggplot(hsq, aes(h2, N_QTLs)) +
  geom_boxplot(aes(group = cut_width(h2, .01))) +
  scale_y_log10() +
  geom_text(aes(x=.02, y= 1000, label=paste("cor:", scales::comma(corr.cor$N_QTLs, accuracy = .01), 
                            "p:", scales::scientific(corr.p$N_QTLs))),color = 'blue')
```

```{r, warning=FALSE, message=FALSE, fig.height=10, fig.width=10}
gridExtra::grid.arrange(gg.bx1, gg.bx2, gg.bx3, gg.bx4, gg.bx5, gg.bx6, nrow=3)
```



